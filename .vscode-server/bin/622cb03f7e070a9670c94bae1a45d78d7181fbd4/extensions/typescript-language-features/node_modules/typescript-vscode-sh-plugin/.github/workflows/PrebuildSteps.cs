// --------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// --------------------------------------------------------------------------------------------

// NOTE: DO NOT IMPORT ANYTHING BESIDES SYSTEM IMPORTS INTO THIS FILE.
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Microsoft.Terrapin.Worker.PrebuildLogic
{
    /// <summary>
    /// A class that contains the logic need to execute before starting a build for an NPM package.
    /// The program looks for the files in the directory in which it was invoked, not necessarily where the prebuild logic is.
    /// As stated above, don't import non-system imports into this file. This is because this file gets uploaded to the docker Oryx build
    /// in the GitHub Actions Pipeline, and it doesn't contain any other files or libraries to import from.
    /// </summary>
    public static class PrebuildNpm
    {
        public const string LockFileName = "package-lock.json";
        public const string PackageFileName = "package.json";
        public const string NpmrcFileName = ".npmrc";
        public const string VersionField = "version";
        public const string IntegrityField = "integrity";
        public const string PrivateField = "private";
        public const string NameField = "name";
        public const string SectionSeparator = "######";
        public const string ExceptionSeparator = "#!#!#!";

        public const string MissingNameErrorMessage = "Missing name field in package.json";
        public const string IncorrectNameErrorMessage = "Incorrect name field in package.json";
        public const string MissingVersionErrorMessage = "Missing version field in package.json";
        public const string IncorrectVersionErrorMessage = "Incorrect version field in package.json";

        /// <summary>
        /// Removes the field `private` from a package.json file because it prevents us from running `npm publish` on the resulting tarball.
        /// </summary>
        public static void RemovePrivateField()
        {
            var pkgText = File.ReadAllTextAsync(PackageFileName)
                .ConfigureAwait(false).GetAwaiter().GetResult();

            var packageData = JsonSerializer.Deserialize<Dictionary<string, object>>(pkgText);
            if (!packageData.ContainsKey(PrivateField))
            {
                Console.WriteLine($"{SectionSeparator} {PackageFileName} does not contain '{PrivateField}' field.");
                return;
            }

            packageData.Remove(PrivateField);
            Console.WriteLine($"{SectionSeparator} Removed '{PrivateField}' field from {PackageFileName}.");
            File.WriteAllTextAsync(PackageFileName, JsonSerializer.Serialize(packageData))
                .ConfigureAwait(false).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Checks to see if there is a 'name' field in the package.json file.
        /// </summary>
        /// <param name="packageName">The name of the package to build.</param>
        public static void CheckPackageJsonName(string packageName)
        {
            var pkgText = File.ReadAllTextAsync(PackageFileName)
                .ConfigureAwait(false).GetAwaiter().GetResult();
            var packageData = JsonSerializer.Deserialize<Dictionary<string, object>>(pkgText);
            if (!packageData.ContainsKey(NameField))
            {
                Console.WriteLine($"{SectionSeparator} {PackageFileName} does not contain '{NameField}' field.");
                throw new PackageJsonException(MissingNameErrorMessage);
            }
            else
            {
                var jsonNameValue = packageData[NameField].ToString();
                if (string.Equals(jsonNameValue, packageName, StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"{SectionSeparator} {PackageFileName} contains correct '{NameField}' field.");
                }
                else
                {
                    Console.WriteLine($"{SectionSeparator} {PackageFileName} contains incorrect '{NameField}' field: expected '{packageName}', got '{jsonNameValue}'.");
                    throw new PackageJsonException(IncorrectNameErrorMessage);
                }
            }
        }

        /// <summary>
        /// Cleans the .npmrc file in case it contains 'package-lock=false'.
        /// If this parameter is set, it prevents Terrapin from executing validations properly.
        /// </summary>
        public static void RemovePackageLockFalse()
        {
            const string packageLockFalse = "package-lock=false";
            const string packageLockFalseRx = @"package-lock\s?=\s?false\r?\n?";
            Regex rx = new Regex(packageLockFalseRx, RegexOptions.Compiled);

            Console.WriteLine($"Checking if {NpmrcFileName} contains '{packageLockFalse}'.");

            var fileText = File.ReadAllTextAsync(NpmrcFileName)
                .ConfigureAwait(false).GetAwaiter().GetResult();
            var matches = rx.Matches(fileText);

            if (matches.Count == 0)
            {
                Console.WriteLine($"{SectionSeparator} {NpmrcFileName} did not contain {packageLockFalse}.");
                return;
            }

            Console.WriteLine($"Trying to remove '{packageLockFalse}'");

            var cleanText = rx.Replace(fileText, string.Empty);
            File.WriteAllTextAsync(NpmrcFileName, cleanText)
                .ConfigureAwait(false).GetAwaiter().GetResult();

            Console.WriteLine($"{SectionSeparator} Successfully rewrote {NpmrcFileName} without {packageLockFalse}.");
        }

        /// <summary>
        /// Checks if the 'version' field in the package.json exists, and if so is it a placeholder version (0.0.0-*) then replace it with
        /// the correct package version to enable a correctly name tarball file from 'npm pack'.
        /// If it is the wrong version, or it is missing, it throws an exception.
        /// </summary>
        /// <param name="packageVersion">The version of the package to build.</param>
        public static void CheckPackageJsonVersion(string packageVersion)
        {
            var pkgText = File.ReadAllTextAsync(PackageFileName)
                .ConfigureAwait(false).GetAwaiter().GetResult();
            var packageData = JsonSerializer.Deserialize<Dictionary<string, object>>(pkgText);
            if (packageData.ContainsKey(VersionField))
            {
                var jsonVersionValue = packageData[VersionField].ToString();
                if (string.Equals(jsonVersionValue, packageVersion, StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"{SectionSeparator} {PackageFileName} contains correct '{VersionField}' field.");
                }
                else if (jsonVersionValue.StartsWith("0.0.0"))
                {
                    Console.WriteLine($"{SectionSeparator} {PackageFileName} contains placeholder for '{VersionField}' field.");
                    packageData[VersionField] = packageVersion;
                }
                else
                {
                    Console.WriteLine($"{SectionSeparator} {PackageFileName} contains incorrect '{VersionField}' field: expected '{packageVersion}', got '{jsonVersionValue}'.");
                    throw new PackageJsonException(IncorrectVersionErrorMessage);
                }
            }
            else
            {
                Console.WriteLine($"{SectionSeparator} {PackageFileName} contains no '{VersionField}' field.");
                throw new PackageJsonException(MissingVersionErrorMessage);
            }

            File.WriteAllTextAsync(PackageFileName, JsonSerializer.Serialize(packageData))
                .ConfigureAwait(false).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Orchestrates all the required pre-build steps for NPM packages.
        /// </summary>
        public static void Main(string[] args)
        {
            string packageVersion = string.Empty;
            string packageName = string.Empty;
            if (args == null || args.Length == 0)
            {
                Console.WriteLine($"{SectionSeparator} No arguments provided, skipping package.json version check.");
            }
            else
            {
                packageName = args[0];
                packageVersion = args[1];
            }

            if (File.Exists(PackageFileName))
            {
                Console.WriteLine($"{SectionSeparator} Removing {PrivateField} from {PackageFileName}, to resolve the build issues caused by private packages");
                TryRunActionAndHandleException(RemovePrivateField);
                TryRunActionAndHandleException(() => CheckPackageJsonName(packageName));

                if (!string.IsNullOrEmpty(packageVersion))
                {
                    Console.WriteLine($"{SectionSeparator} Verifying that {VersionField} is present and correct in {PackageFileName}.");
                    TryRunActionAndHandleException(() => CheckPackageJsonVersion(packageVersion));
                }
            }
            else
            {
                Console.WriteLine($"{SectionSeparator} {PackageFileName} file not found");
            }

            if (File.Exists(NpmrcFileName))
            {
                Console.WriteLine($"{SectionSeparator} Found {NpmrcFileName}, attempting a cleanup...");
                TryRunActionAndHandleException(RemovePackageLockFalse);
            }
            else
            {
                Console.WriteLine($"{SectionSeparator} {NpmrcFileName} file not found");
            }
        }

        /// <summary>
        /// Tries to run a given action, handling any exception thrown and writing it out to the console.
        /// </summary>
        /// <param name="action">The action to be run.</param>
        private static void TryRunActionAndHandleException(Action action)
        {
            try
            {
                action();
            }
            catch (Exception exc) when (!(exc is PackageJsonException))
            {
                Console.WriteLine($"{ExceptionSeparator} {exc.Message}");
            }
        }

        /// <summary>
        /// Exception used for the Prebuild script that gets thrown if the package.json has invalid properties/formatting/missing an entry.
        /// Or throws it if the package.json differs from the package that was queued to build.
        /// </summary>
        public class PackageJsonException : Exception
        {
            public PackageJsonException(string message)
                : base(message)
            {
            }
        }
    }
}
